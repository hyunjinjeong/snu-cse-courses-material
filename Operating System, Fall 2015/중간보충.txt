보충수업 1

1. Introduction

- 컴퓨터 시스템의 구성

하나의 컴퓨터가 아니라 네트워크로 연결된 여러가지 컴퓨터를 합쳐 컴퓨터 시스템이라고 한다.
여기서 핵심적인 역할을 하는 것이 미들웨어. 미들웨어의 기능은 네트워크에서 컴퓨터 상호간 정보를 교환하거나 서로 상대방의 자원을 활용하는 관계를 맺어줌.(협동관계, 상호작용)
시스템 소프트웨어에 포함하면 비효율적이기 때문에 따로 놔둠. 윈도우는 시스템 소프트웨어에 미들웨어의 기능이 대부분 포함되어 있음.

- 컴퓨터 시스템의 진화

응용과 시스템이 함께 진화하고 있다.(분산 모바일 시스템, IOT로 진화됨) 응용은 다기능화, 고기능화, 다양화가 되고 있다. 시스템은 생산성을 높임.
모든 진화를 가능하게 한 것이 반도체 칩. 칩의 집적도가 향상되면서 컴퓨터 시스템의 원동력이 됨.
컴퓨터와 반도체 칩은 상호작용(칩 설계, 회로 등은 컴퓨터가 함) -> 선순환.

- 운영체제 목적 및 생태환경

생태환경을 잘 이해하고 있어야 함.

- Summary

인터럽트, DNA 등을 배움. 멀티프로세서에서 중요한 것은 공유 메모리(공유 기억)을 통해 통신을 한다는 점. 이에 대칭되는 것이 메세지에 의해 통신하는 방법.(요건 multiple processor라고 할 수 있음.)
멀티코어는 마이크로프로세서 칩 속의 cpu가 많은 것.
시분할 시스템은 대형 컴퓨터를 중앙에 두고 기능이 거의 없는 dumb terminal로(거의 입출력만 함) 연결된 시스템. 이것의 특징 중의 하나가 멀티 프로그래밍과 연결되어 스케쥴링으로 RR을 씀.
사용자 모드와 커널 모드를 나누어, 둘 사이를 왔다 갔다 할 수 있는 것은 하드웨어적으로 가능. OS는 기본적으로 커널 모드로 작동.
client-server 시스템이 인터넷으로 가면 웹 서버가 있고 클라이언트가 있음. 클라이언트는 시분할에서 dumb terminal같음.
클라우드 컴퓨팅은 client-server와 비슷한데 이름이 달라짐.



2. System structures

- 플랫폼으로서의 운영체제

응용 쪽에서는 운영체제는 하나의 플랫폼. 특히 응용 개발자들은 운영체제에서 API만 보게 함으로써 전체적인 복잡한 시스템을 감춤. 
API는 시스템 콜, 시스템 서비스의 집합. 표준화된 모양이며 문서화가 잘 되어있음. 

- 시스템 서비스

시스템은 사용자 레벨과 커널 레벨로 분리.

- Summary

OS의 구조는 다양함. 시스템마다 달라서 일률적으로 어떤 OS가 어떤 구조라는 것을 단정지을 순 없지만 특징적인 점들이 있음.
마이크로커널: 핵심되는 부분을 작게 만들어 하드웨어 플랫폼을 자유롭게 옮겨갈 수 있음. 그 위 서비스가 올라와서 유동적으로 할 수 있음. message passing을 통해서 통신하기 때문에 시간이 많이 걸리는 단점이 있음.
	      커널이 매우 작게 구현되어 있기 때문에 외부에서 직접 들어갈 수 있는 방법이 없음. 그래서 보안이 좋다고 한 것.
적재 가능한 모듈(loadable module): device driver 같은 모듈들이 run time에 필요할 때 탑재할 수 있음.



3. Process Concept

- 프로세스란 무엇인가? 사용 동기는?

프로그램에서 프로세스가 가장 핵심적인 요소. 프로세스는 프로그램이 실행되는 그 자체. 

- 프로세스와 운영체제 환경

프로세스의 실체를 구성하는 것이 원 안에 있음.(메모리맵, 프로세스 상태.) 또 프로세스를 구성하는 것 중에 PCB가 있음.  
프로세스간 통신은 크게 두 가지: 공유 메모리, 메세지 전달

- Summary

쓰레드는 프로세스의 실행의 궤적. 
스케쥴러는 long, short가 있음. dispatcher는 스케쥴러 안에 있을 수도 있고 따로 있을 수도 있음. context switching을 dispatcher에서 함.
프로세스 연산에서 wait은 parent process가 child process가 끝날 때까지 기다리는 것. child가 끝나고 나면 child의 자원들을 모두 정리해주고 마무리.
parent가 wait을 안 하면 child가 수행을 마치고 끝나도 자원 정리가 안 됨. zombie process. 그래서 init process가 처리해줌.
프로세스간 통신에서 메세지 이용에서 직접과 간접으로 나누어짐. 랑데뷰는 서로가(sender, receiver) 모두 block되어있는 상태를 말함. 장점은 동기화가 확실하다는 점.



4. Multithreaded Programming

- 쓰레드, 쓰레드로 처리하기

쓰레드는 프로세스 안에서 도는 것. 프로세스 안의 실행 주체들. 특징은 프로세스의 address state를 쓰레드간에 공유. 그래서 thread간 데이터 공유가 편리함. 
thread의 장점: 쉽게 공유 가능. 단점은 그로 인한 안전 문제. 

- 쓰레드의 구현

쓰레드가 커널 레벨 쓰레드인지, 유저 레벨 쓰레드인지 두 가지로 나뉨. 용어에 크게 중점 ㄴㄴ. 처음부터 나눠진 것이 아니라 하다 보니 나눠진 것.
type A: 커널 코드만 수행할 수도 있고
type B: 유저 프로세스에서 쓰레드를 사용할 수도 있음. 사용자 레벨에서의 transaction을 여러 사용자에게 처리하는데 쓰레드로 함. 스케쥴링도 프로세스에서 함. 쓰레드 관련 데이터 스트럭쳐나 라이브러리도 모두 유저 레벨에 존재.
        커널에서는 그냥 프로세스 하나로 봄. 문제점으로 쓰레드 하나가 block되면 다른 모든 쓰레드가 block된다는 점이 있음.
	여러 개의 사용자 쓰레드가 하나의 커널 쓰레드로 맵핑되는 경우가 여기.(many to one)
type C: 시스템 콜 사용해서 유저 프로세스에서 쓰레드를 만들지 않고 커널에서 만들어 줌. 그래서 커널에서 쓰레드에 대한 존재를 알게 됨. 그래서 커널에서 쓰레드 관리를 할 수 있다는 점이 장점.
	스케쥴링을 쓰레드별로 할 수 있음. 그래서 쓰레드 하나가 block되어도 나머지는 정상적으로 수행할 수 있음.
        여긴 여러개가 여러개.(many to many model)

pthread 패키지를 쓸 때 유저 레벨에서 구현하면 type B가 되고, 시스템콜화 해서 처리하면 type C가 됨.

- 쓰레드 이용의 장점

병행계산(concurrent)이 프로세스 내에서 가능하게 됨. 또한 특히 서버에서, 사용자가 많을 때 쓰레드를 이용하면 자원을 효율적으로 사용하며 처리 가능.

- Summary

thread pool: 서버에서 많은 사용자가 요청할 때를 대비한 기술로 적절한 기술임. 쓰레드를 미리 만들어 놓고 요청이 들어오면 요청을 기존에 만들어져 있는 쓰레드에 할당해서 처리.
implicit threading: 프로그래머가 쓰레드 생성하지 않고 컴파일러나 런타임 라이브러리가 쓰레드 생성.
쓰레드를 사용하거나 설계할 떄 process level의 시그널을 처리하는 문제가 있음.

- Scheduler Activation(4장 두번째 ppt내용)

여긴 설명안함.



5. Process Scheduling

- 모든 길은 스케쥴러로 통한다

동적인 상황에서 스케쥴러가 모든 권한 가짐.
스케쥴러를 가운데 놓고 보면 다른 것들은 수동적이라고 볼 수 있음. 스케쥴러는 능동적.

- 스케쥴링 - 무엇을, 왜, 어떻게?

스케쥴링을 할 때는 ready queue라는 곳에 넣어 수행을 원하는 process나 thread들을 한 군데 모아서 관리.
queueing 알고리즘에서는 수행하는 부분을 server로 보고 queue를 client로 봄.

- 우선 순위를 따르는 세상

프로세스 총 수행시간에서 코드 실행시간은 줄일 수 없지만 나머지 블로킹+선점된 시간을 줄이는 것이 중요.

- Summary

멀티프로세서 스케쥴링에서는 여러 개의 코어를 병렬적으로 수행하는데, 가장 중요한 것은 부하균배(load balancing)
실시간 스케쥴링의 특징은 시간제약을 가지고 있다는 것. 가장 중요한 시간 제약조건이 deadline. 동적은 EDF, 정적은 RM
RM의 가장 큰 의의는 이론적으로 스케쥴링의 확실성을 증명할 수 있다는 것.(upper bound보다 작으면 항상 스케쥴링 가능)



6. Synchronization

- 왜 동기화하여야만 하는가?

데이터의 정확성을 깨지는 현상을 막기 위해 동기화.

- 어떻게 질서정연한 접근을 보장할까?

방법: 임계영역, 모니터

- Summary

뮤텍스는 항상 같은 자원에 대한 acquire와 release를 같은 프로세스가 수행해야 함. 세마포어는 안 그래도 됨.
모니터: abstract data type(데이터를 직접 access할 순 없고 함수를 통해서만 data를 access할 수 있음).
	여기에 있는 함수를 호출하려면 lock을 통과해야 함. 그래서 한번에 하나만 모니터 속에서 수행 가능.
	근데 그럴 경우 병행성이 모자람. 병행성을 주기 위해 조건마다 기다리고 다른 조건끼리는 병행적으로 수행될 수 있게 condition variable 사용.
	


7. Deadlocks

- 교착상태 - deadlock

서로가 서로를 기다려서 더 이상 진행이 안 되는 상황. 동작이 멈추는 효과. 스스로 해결 불가.
현실적으로 가장 많이 쓰고 있는 방법이 무시하는 방법.
간접적으로 deadlock을 해결하는 방법 중 많이 쓰이는 것이 timeout. 기다리다가 일정 시간이 지나면 timeout.

- Summary

deadlock 필요조건 4가지. 한 가지만 깨도 deadlock 풀림.
이론석으로 cycle이 있으면 deadlock이 발생할 수 있음. cycle의 유무를 체크.
banker's algorithm: 프로세스가 여러 개 있을 때, 어떤 순서로 실행해야 deadlock이 안 발생하는 지 검사
복구에서 프로세스 취소한 뒤 roll-back할 때 checkpoint를 만들어 거기부터 다시 실행.